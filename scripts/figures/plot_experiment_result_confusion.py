import argparse
import pathlib

import h5py
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator

import numpy as np


HDF5_EXTENSION    = ".h5"
PROJECT_ROOT_PATH = pathlib.Path(__file__).parent.parent.resolve().parent
RESULTS_PATH      = PROJECT_ROOT_PATH / 'share' / 'Experiments' / 'Results'
assert RESULTS_PATH.exists() and \
       RESULTS_PATH.is_dir(), \
      "Cannot find Experiments/Results directory: {RESULTS_PATH}"
FIGURES_PATH      = PROJECT_ROOT_PATH / 'share' / 'Experiments' / 'Figures'


def accuracy(true_positive: int,  true_negative: int,
             false_positive: int, false_negative: int) -> float:
    """
    Returns the accuracy value for the given confusion matrix.
    """
    return (true_positive + true_negative) / float(true_positive + false_positive + true_negative + false_negative)


def precision(true_positive: int, false_positive: int) -> float:
    """
    Returns the precision value for the given confusion matrix.
    """
    return true_positive / float(true_positive + false_positive)


def arr_accuracy(arr: np.ndarray):
    """
    Calls the `accuracy` function on the input array.
    """
    return accuracy(arr[0], arr[1], arr[2], arr[3])


def arr_precision(arr: np.ndarray):
    """
    Calls the `precision` function on the input array.
    """
    return precision(arr[0], arr[2])


def get_metric_occupancy_confusion_group(hdf5_path: pathlib.Path) -> h5py.Group:
    """
    Opens an HDF5 file and access the location of the Confusion Matrix data.
    """
    h5_file  = h5py.File(hdf5_path, "r")
    h5_group = h5_file["Metric"]["OccupancyConfusion"]
    return h5_group


def select_experiment() -> pathlib.Path:
    """
    Selects one from the possible experiment directories.
    """
    experiments = [x for x in RESULTS_PATH.iterdir() if x.is_dir()]
    if len(experiments) == 0:
        print("No experiment directories available")
    elif len(experiments) == 1:
        return experiments[0]

    print("Please select which experiment directory to use:")
    for i, experiment in enumerate(experiments):
        print(f"[{i}] {experiment.name}")
    idx = int(input("Enter experiment number: "))
    return experiments[idx]


def plot_policy_sweep(policy_path: pathlib.Path):
    """
    Generates the accuracy and precision plots. Combines the multiple policy view into one plot and
    if the policy was repeated then it plots the min/max and average with standard deviation bars.
    The generated figure is then saved.
    """
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=[12.8, 6.4], dpi=200)

    fig_title = f"{policy_path.parent.name.capitalize()}: {policy_path.name}".replace("_", " ")
    fig.suptitle(fig_title)

    ax1.set_title("Reconstruction Accuracy")
    ax1.set_xlabel("Views Added")
    ax2.set_title("Reconstruction Precision")
    ax2.set_xlabel("Views Added")

    try:
        # Sort in increasing order on integer number.
        views_dirs = sorted([x for x in policy_path.iterdir() if x.is_dir()],
                            key=lambda x: int(str(x.name)), reverse=True)
    except ValueError:
        print("Could not turn directory name into integer for the number of views generated by the policy.")
        raise

    for views in views_dirs:
        line_label = f"{views.name} Views"

        views_plus_one = 1 + int(views.name)
        xdata = list(range(views_plus_one))

        reps_dirs = [x for x in views.iterdir() if x.is_dir()]
        data = np.zeros((int(views.name), 4, len(reps_dirs)))
        acc  = np.zeros((views_plus_one, len(reps_dirs)))
        pre  = np.zeros((views_plus_one, len(reps_dirs)))

        for i, reps in enumerate(reps_dirs):
            hdf5_dir = reps / "results.h5"
            confusion_group = get_metric_occupancy_confusion_group(hdf5_dir)
            data[:, :, i] = confusion_group.get("data")[:, 1:5]
            acc[1:, i]     = np.apply_along_axis(arr_accuracy,  1, data[:, :, i])
            pre[1:, i]     = np.apply_along_axis(arr_precision, 1, data[:, :, i])

        if len(reps_dirs) > 1:
            line_label += " (Average)"
            acc_avg = acc.mean(axis=1)
            acc_std = acc.std(axis=1)
            acc_min = acc.min(axis=1)
            acc_max = acc.max(axis=1)
            ax1.errorbar(xdata, acc_avg, acc_std, linewidth=2, label=line_label, elinewidth=1, alpha=0.75, capsize=4.5)
            ax1.fill_between(xdata, acc_min, acc_max, alpha=0.2)

            pre_avg = pre.mean(axis=1)
            pre_std = pre.std(axis=1)
            pre_min = pre.min(axis=1)
            pre_max = pre.max(axis=1)
            ax2.errorbar(xdata, pre_avg, pre_std, linewidth=2, label=line_label, elinewidth=1, alpha=0.75, capsize=4.5)
            ax2.fill_between(xdata, pre_min, pre_max, alpha=0.2)
        else:
            ax1.plot(xdata, acc[:, 0], linewidth=2, label=line_label)
            ax2.plot(xdata, pre[:, 0], linewidth=2, label=line_label)

    ax1.legend()
    ax2.legend()

    ax1.xaxis.set_major_locator(MaxNLocator(integer=True))
    ax2.xaxis.set_major_locator(MaxNLocator(integer=True))

    # Split the old path to get the location of the figure.
    image_fpath = (FIGURES_PATH / policy_path.relative_to(RESULTS_PATH)).parent
    if image_fpath.exists() is False:
        image_fpath.mkdir(parents=True)
    image_fpath /= policy_path.name + "_Results.png"
    plt.savefig(image_fpath)
    plt.close()


def main(_: argparse.Namespace) -> None:
    """
    Program entry point.
    """
    experiment_dir = select_experiment()
    shape_dirs = [x for x in experiment_dir.iterdir() if x.is_dir()]
    for shape in shape_dirs:
        policy_dirs = [x for x in shape.iterdir() if x.is_dir()]
        for policy in policy_dirs:
            plot_policy_sweep(policy)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog='Plot Experiment Result Confusion',
        description='This script iterates through a set of experiment results (generated by the '
                    'sweep_run_experiment.py script) and creates condensed accuracy and precision '
                    'results for a policy reconstructing a specific shape.'
    )

    args = parser.parse_args()
    try:
        main(args)
    except KeyboardInterrupt as e:
        print("\nExiting early on KeyboardInterrupt.")
